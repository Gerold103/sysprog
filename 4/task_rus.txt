------------------------------------------------------------------
Пул потоков.
Язык: C/C++
Время: 3 недели.
Сложность: ~10 часов в среднем, 330 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Нужно реализовать пул потоков. В разных программах, выполняющих
много независимых и легко распараллеливаемых задач часто бывает
удобно разносить их по разным потокам. Но создавать поток на
каждую необходимость что-то вынести в него довольно дорого по
времени и ресурсам. Если задача не слишком долгая, не читает диск,
сеть, то создание/удаление потока может занять больше времени, чем
сама задача.

Тогда обычно либо задачи вообще не параллелят, либо при их большом
количестве создают пул потоков. Это такой резерв рабочих потоков,
который имеет очередь задач и некое число потоков, которые с
очереди задачи забирают. Таким образом, можно всегда иметь под
рукой уже созданный поток, который может быстро подхватить любую
задачу, а в конце вместо завершения возьмет следующую.

В библиотеках часто есть уже готовое решение: в Qt это класс
QThreadPool, в .NET это класс ThreadPool, в boost это класс
thread_pool. В задании нужно реализовать свое, подобное.

В файлах thread_pool.h и thread_pool.cpp можно найти шаблоны
функций и структур, которые надо реализовать.

Пул потоков описывается структурой struct thread_pool,
реализованной в thread_pool.cpp, а у пользователя может быть на
нее только указатель. Каждая задача аналогично описывается
структурой struct thread_task, которые пользователь может
создавать и класть в пул в очередь.

Пользователь может проверять состояние задачи (ждет постановки в
поток; уже в потоке и выполняется), можно дождаться ее завершения
и получить результат при помощи thread_task_join, наподобие
pthread_join.

Поскольку задача - реализация библиотеки, то программы main нет, а
значит и принимать на вход некуда. Вы можете писать тесты на С, в
отдельном файле, где будет main, и куда будет делаться include
вашего решения. Например, создается файл main.cpp, который делает
include "thread_pool.h" и в функции main делает какие-то тесты.
Это все собирается так:

        gcc thread_pool.cpp main.cpp

---------------------------- Правила -----------------------------

- thread_pool при создании через thread_pool_new() не должен сразу
  стартовать все потоки. Потоки должны создаваться по мере
  необходимости, пока не достигнут лимита, заданного пользователем
  в thread_pool_new().

- Присоединенные, но не удаленные таски могут быть пушнуты обратно
  в пул.

- Остальные правила можно увидеть в документации в thread_pool.h и
  понять из тестов.

-------------------------- Ограничения ---------------------------

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  опцию cmake - `ENABLE_LEAK_CHECKS`. Показать репорты с нулем
  утечек от Valgrind или ASAN не достаточно - они часто пропускают
  утечки.

- Код не должен содержать циклы активного ожидания (busy loops и
  sleep loops). Они разрешены только в тестах. То есть в
  thread_task_join() нельзя делать
  'while (!task->is_finished) {usleep(1)};'. Для ожидания чего
  либо нужно использовать pthread_cond_t.

- Нельзя использовать malloc(), realloc(), calloc(), и подобные
  функции. Можно использовать только new и delete из C++.

-------------------------- Послабления ---------------------------

- Нет лимита на количество мьютексов и условных переменных
  (condition variable). Можно даже иметь их в каждом таске.

- Можно считать, что функции работы с памятью new и delete никогда
  не ошибаются.

------------------------ Варианты решения ------------------------

- 15 баллов: реализовать все функции из thread_pool.h, которые не
  скрыты макросами.

- +5 баллов: реализовать thread_task_detach(). Документация есть в
  thread_pool.h. Нужно определить макрос NEED_DETACH.

- +5 баллов: реализовать thread_task_timed_join(). Документация
  есть в thread_pool.h. Нужно определить макрос NEED_TIMED_JOIN.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 250-400, в среднем 330.

- Затраченное время на все:
  * Продвинутый уровень: ~6 часов.
  * Средний уровень:    ~10 часов.
  * Мало практики:      ~19 часов и более.

- Распределение времени:
  * Активный кодинг: ~2-4 часа.
  * Остальное - в основном отладка. Она довольно непростая в
      многопоточной среде.

-------------------------- Как запусить --------------------------

Для сборки задачи используется CMake. Вот так можно им
воспользоваться:

- Идем в папку задачи, так что наш путь становится
  <...>/sysprog/4/.
- Создаем папку build и идем в нее:
    mkdir build
    cd build
- Конфигурируем:
    cmake ..
- Компилируем:
    make
- Теперь можно запустить тесты:
    ./test

В CMake можно задавать опции. Например, если есть опция
SOME_OPTION, то ее можно установить в некое значение через такую
команду:
    cmake -DSOME_OPTION=value ..

Для этой задачи доступны следующие опции:

- ENABLE_LEAK_CHECKS - собрать с утилитой heap_help, чтобы
    проверять отсутствие утечек и в целом проблем с кучей:
  - 0 = выключить
  - 1 = включить

- ENABLE_GLOB_SEARCH - собрать все C и C++ файлы в текущей папке.
    Обычно нужно, когда вы решили создать свои дополнительные
    файлы, и не хотите их все перечислять по одному.
  - 0 = выключить
  - 1 = включить

- CMAKE_BUILD_TYPE.
  - Release = включить оптимизации компилятора. Быстрее работает,
      но сложнее дебажить интерактивно.
  - Debug = выключить оптимизации компилятора. Обратный эффект от
      Release.

----------------------- Советы и подсказки -----------------------

- Попробуйте спросить ChatGPT или другой ИИ про теорию, если у вас
  сложности с базовыми концептами многопоточности.

- Очень важно понимать следующие вещи: что такое поток, что такое
  мьютекс, и что такое "условная переменная" (condition variable).

  Поток - это одним словом "исполнитель" или executor. Что-то, что
  может исполнять код. Когда у вас много потоков, они могут
  исполнять один и тот же или разный код буквально параллельно,
  на разных физических ядрах процессора.

  Мьютекс - это способ защиты данных от доступа из нескольких
  потоков одновременно. Такое нужно, когда вы хотите обновить или
  прочитать некий сложный стейт (несколько переменных сразу, или
  сделать несколько действий с одной переменной - например,
  инкремент) и это нельзя сделать одной машинной инструкцией.
  Тогда вы лочите мьютекс, делаете работу, и разлочиваете мьютекс.
  Между локом и анлоком только один поток сможет делать работу.

  Условная переменная - это способ заблокировать поток так, что он
  будет ждать некое событие или "условие". Отсюда и название -
  "условная переменная". Работает это так, что один поток
  блокирует мьютекс, проверяет некое условие, видит, что оно не
  удовлетворено, и ждет этого условия. Другой поток рано или
  поздно тоже возьмет лок мьютекса и "удовлетворит" это условие
  или "просигналит" его. Это разбудит первый поток. И он далее
  может еще раз проверить, что условие действительно случилось.
  Рекомендуется почитать открытые источники в сети с реальными
  примерами.

- Когда делаете бонус на детач, особое внимание уделите случаю,
  когда один поток зовет detach(), и в то же время задача
  завершается в другом потоке. Здесь довольно легко допустить
  утечку или use-after-free. Нужно убедиться, что если detach()
  вызван, то либо задача уже завершена и удалется, либо будет
  удалена автоматически, когда она наконец будет завершена.

- Когда включен heap_help, тесты могут тормозить. Для ускорения
  отладки рекомендуется уменьшить константу TPOOL_MAX_TASKS.
  Только надо ее откатить назад перед посылкой финального решения.
