------------------------------------------------------------------
Шина сообщений для корутин
Язык: C/C++
Время: 3 недели.
Сложность: ~10 часов в среднем, 500 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Есть объект "шина сообщений", как на материнской плате. В шине
можно открывать каналы, в которые можно засылать простые
сообщения.

Нужно реализовать эту шину с поддержкой корутин.

Корутина, так же известная как сопрограмма, легкий поток,
виртуальный поток, "зеленый" поток, файбер - это единица
исполнения кода. Она выполняет линейный код и имеет стек, так же
как настоящие потоки, но корутина не управляется ядром. Напротив,
корутины - это объекты пользовательского пространства, и их
шедулинг целиком происходит здесь же. Самый простой сценарий, это
когда один поток имеет внутри много корутин и переключается между
ними по очереди.

Корутины уже реализованы, и идея шины сообщений весьма проста.
Основная сложность задачи - сделать шину совместимой с корутинами.

Например, канал в шине имеет максимальную емкость. Когда корутина
пытается послать сообщение в канал, который уже полон, корутина
должна быть поставлена на паузу, пока в канале не освободится
место.

Тесты находятся в test.cpp. Шаблон реализации - в corobus.h и
corobus.cpp. API корутин находится в libcoro.h. Прочие файлы можно
игнорировать. Кроме случаев, когда хочется узнать внутренности
тестов или корутин. Например, libcoro_test.cpp просто тестирует
сам движок корутин. В задаче не требуется что-либо в этом движке
менять. Просто пользуйтесь API.

---------------------------- Правила -----------------------------

- Реализация должна строго следовать поведению, определенному в
  комментариях в corobus.h.

- Все тесты должны пройти.

- Код должен собираться успешно с данными флагами компилятора:
  `-Wextra -Werror -Wall -Wno-gnu-folding-constant`.

-------------------------- Ограничения ---------------------------

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  опцию cmake - `ENABLE_LEAK_CHECKS`. Показать репорты с нулем
  утечек от Valgrind или ASAN не достаточно - они часто пропускают
  утечки.

- Нельзя менять test.cpp, libcoro.cpp, libcoro.h.

-------------------------- Послабления ---------------------------

- Можно считать, что функции работы с памятью типа new/delete/
  malloc()/realloc()/calloc() никогда не ошибаются.

- Можно использовать интрузивный список из utils/rlist.h.

------------------------ Варианты решения ------------------------

- 15 баллов: пройти все тесты.

- +5 баллов: реализовать broadcast. Чтобы включить тесты на
  broadcast, вам следует определить макрос NEED_BROADCAST в 1 в
  corobus.h. Тесты должны пройти. В corobus.h вы найдете broadcast
  функции и описания того, что они должны делать.

- +5 баллов: векторные send/recv. Чтобы включить соответствующие
  тесты, вам следует определить макрос NEED_BATCH в 1 в corobus.h.
  Тесты должны пройти. В corobus.h вы найдете эти функции и
  описания того, что они должны делать.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 350-700, в среднем 500.

- Затраченное время на все:
  * Продвинутый уровень: ~6 часов.
  * Средний уровень:    ~10 часов.
  * Мало практики:      ~19 часов и более.

- Распределение времени:
  * Активный кодинг: ~2-4 часа.
  * Остальное - чтение кода, понимание задачи и корутин, отладка.

-------------------------- Как запусить --------------------------

Для сборки задачи используется CMake. Вот так можно им
воспользоваться:

- Идем в папку задачи, так что наш путь становится
  <...>/sysprog/1/.
- Создаем папку build и идем в нее:
    mkdir build
    cd build
- Конфигурируем:
    cmake ..
- Компилируем:
    make
- Теперь можно запустить тесты:
    ./test

В CMake можно задавать опции. Например, если есть опция
SOME_OPTION, то ее можно установить в некое значение через такую
команду:
    cmake -DSOME_OPTION=value ..

Для этой задачи доступны следующие опции:

- ENABLE_LEAK_CHECKS - собрать с утилитой heap_help, чтобы
    проверять отсутствие утечек и в целом проблем с кучей:
  - 0 = выключить
  - 1 = включить

- ENABLE_GLOB_SEARCH - собрать все C и C++ файлы в текущей папке.
    Обычно нужно, когда вы решили создать свои дополнительные
    файлы, и не хотите их все перечислять по одному.
  - 0 = выключить
  - 1 = включить

- CMAKE_BUILD_TYPE.
  - Release = включить оптимизации компилятора. Быстрее работает,
      но сложнее дебажить интерактивно.
  - Debug = выключить оптимизации компилятора. Обратный эффект от
      Release.

----------------------- Советы и подсказки -----------------------

- Попытайтесь почитать libcoro_test.cpp и test.cpp, чтобы
  посмотреть, как корутины используются. Попробуйте запустить
  libcoro_test.cpp, добавит принтов, воспользоваться отладчиком,
  чтобы понять, как что работает.

- Почитайте libcoro.h, чтобы узнать, какое API корутин вам
  доступно, и что для вашего решения будет полезно.

- Попробуйте спросить ChatGPT или другой ИИ, что такое корутины,
  если вам нужно больше информации про понятие "корутин" в целом.

- Корутины в задаче очень похожи ны горутины в языке Go. Объект
  "corobus" очень похож на каналы в том же Go.

- Разобравшись, как работают libcoro корутины, попробуйте
  спроектировать дизайн своей шины. В голове, затем записав как
  текст. Не начинайте кодинг до того, как понимаете, что именно
  кодить. Всегда сначала дизайн, потом код.

- Реализуйте сначала try_send, try_recv, и прочие try. Они не
  будут блокировать текущую корутину, а потому довольно
  тривиальны. Затем попробуйте сделать send через try_send, recv
  через try_recv, и тд.

Еще заметка про корутины. Если все еще непонятно, то попробуйте
посмотреть на них с другой точки зрения - думайте про корутины как
про "сопрограммы" или "resumable functions" или "функции-объекты,
которые можно ставить на паузу".

Каждая корутина имеет как тело одну главную функцию (данную вами
в coro_new()). Эта функция может звать другие функции и в целом
работать как любой обычный код. Но эта функция может быть
поставлена на паузу. Это происходит, когда вы делаете yield
(зовете coro_yield()). И ее можно продолжить (зовем
coro_wakeup()).

Например, можно создать и запустить корутину-1, она что-то делает,
ставится на паузу, затем корутина-2 создается и что-то делает,
тоже ставится на паузу, затем корутина-1 продолжает работу, пока
ее тоже не поставят на паузу, и тд.

Корутины - как объекты, буквально сишные структуры. В одном
процессе, в одном потоке их может быть много. И вы, как
пользователь корутин, можете выбирать какие из этих
объектов-функций вы продолжаете или ставите на паузу и когда.

Помните, что вся задача происходит в одном потоке. Корутины
исполняются чередуясь, и никогда не работают буквально
параллельно. Конкуретно - да, параллельно - нет. Мьютексы и все
прочие способы синхронизации потоков здесь не нужны.
