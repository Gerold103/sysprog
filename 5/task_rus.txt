------------------------------------------------------------------
Игровой чат.
Язык: C/C++
Время: 3 недели.
Сложность: ~15 часов в среднем, 1100 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Нужно реализовать чат игрового лобби. Он состоит из сервера и
клиента.

Клиент подключается к серверу, и каждое сообщение клиента
рассылается всем остальным клиентам через сервер. Получается, что
сервер - как бы игровое лобби. Каждый видит сообщения каждого и
сообщения никуда никак не сохраняются надолго.

В прикрепленных .h и .cpp файлах раскиданы шаблоны функций и
структур, которые надо реализовать.

Пример использования исполняемых файлов - запускается сервер и
один или несколько клиентов. Все рассылается всем:

$> ./server             $> ./client             $> ./client
I am client-1!          I am client-1!          I am client-1!
I am client-2!          I am client-2!          I am client-2!

---------------------------- Правила -----------------------------

- Сообщение кончается `\n` (перенос строки). Заметьте, что '\n' не
  является частью сообщения. Это просто разделитель. То есть если
  вызван feed('msg\n'), то участники чата должны вернуть 'msg' из
  pop(). Также учтите, что feed() может получить несколько целых
  сообщений или даже их части:
  - feed('msg1\nmsg2\n') - pop() вернет 'msg1' и 'msg2';
  - feed('msg1\nms') - pop() вернет 'msg1'. 'ms' остается во
    внутреннем буфере пока не встретится '\n'.

- Собственные сообщения обратно клиенту с сервера не посылаются.

- Пустые сообщения (состоящие только из пробельных символов - см.
  функцию isspace()) не отправляются вообще.

- С каждого сообщения слева и справа обрезаются все пробельные
  символы. Например, если я ввожу "  m s   g   " в терминале и жму
  enter, то будет отправлено сообщение "m s   g".

-------------------------- Ограничения ---------------------------

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  опцию cmake - `ENABLE_LEAK_CHECKS`. Показать репорты с нулем
  утечек от Valgrind или ASAN не достаточно - они часто пропускают
  утечки.

- Нельзя использовать sleep()/usleep() или подобные функции. Все
  ожидания чего-либо должны быть сделаны на epoll или poll или
  kqueue.

- Функция select() запрещена (она устарела, сломана, и просто
  является плохой практикой - никогда ее не используйте).

- Все сокеты должны быть неблокирующими (O_NONBLOCK). Однако на
  стороне клиента разрешается создать сокет блокирующим, сделать
  блокирующий connect(), и уже потом сделать сокет неблокирующим.

- Никаких бизи-лупов (busy-loop) / активных ожиданий где-либо.

- Будьте готовы, что send/write и подобные функции отправки данных
  могут отправить часть данных, а не все целиком. Например,
  send(100) может вернуть 60.

- API в заголовках менять нельзя (кроме случаев, когда там
  ошибка - тогда надо сказать мне).

- В epoll нужно использовать epoll_event.data.ptr, а в kqueue -
  kevent.udata. Использование epoll_event.data.fd запрещено. Поля
  ptr/udata нужны для сопоставления событий к их сокетам после
  возврата событий из epoll_wait() и kevent().

- При использовании epoll нужно прочитать про EPOLLET и
  использовать его. EPOLL_CTL_MOD запрещен. Использование
  EPOLL_CTL_ADD/DEL для симуляции MOD также запрещено. Сокет
  должен быть добавлен в epoll единожды при создании, и удален
  оттуда перед закрытием. Конкретно это означает, что звать
  epoll_ctl() на одном и том же сокете более двух раз **нельзя** -
  только чтобы добавить и удалить из очереди. Тоже самое про
  kqueue.

- При использовании kqueue нужно обязательно ставить EV_CLEAR. Все
  те же самые ограничения, что с epoll, применяются и здесь. То
  есть нельзя добавлять и удалять события у сокета. Сокет должен
  быть добавлен в kqueue единожды со всеми своими событиями и
  оставаться там до своего закрытия.

- На серверной стороне нужно использовать epoll или kqueue.

- На клиентской стороне нужно использовать poll() (не epoll).

- Прикрепленный makefile должен оставаться рабочим, компиляция
  должна иметь 0 предупреждений и ошибок. Либо можно переделать на
  cmake, но все опции компиляции нужно сохранить.

- Нельзя использовать malloc(), realloc(), calloc(), и подобные
  функции. Можно использовать только new и delete из C++.

-------------------------- Послабления ---------------------------

- Можно полагать, что очереди сообщений всегда достаточно малы,
  чтобы поместиться целиком в память.

- Можно полагать, что буферы ввода и вывода всегда помещаются в
  память.

- Можно использовать abort() для критичных ошибок. Например, если
  не получилось создать epoll-дескриптор или сокет.

- Можно считать, что функции работы с памятью new и delete никогда
  не ошибаются.

- Буфер вывода может быть в любом формате. Например, копировать
  каждое сообщение поданное в feed() и хранить их в списке. Или
  копировать все сообщения в один большой буфер в его конец.

- Можно полагать, что клиент и сервер используют только адреса
  IPv4.

------------------------ Варианты решения ------------------------

- 15 баллов: реализовать все функции из всех .h и .cpp файлов, как
  описано выше и в самих файлах (кроме опциональных функций из
  бонусных решений).

- +5 баллов: поддержка имен клиентов. В chat_client_new() есть
  параметр 'name'. Его надо отправить на сервер и показывать перед
  каждым сообщением этого клиента на всех остальных клиентах. Если
  это делаете, то надо определить макрос NEED_AUTHOR.

  Для засчитывания этого бонуса клиенты должны посылать свое имя
  серверу только один раз.

  Этот бонус лучше всего планировать заранее. Иначе будет сложно
  добавить его в уже реализованное базовое решение.

- +5 баллов: реализовать серверные сообщения - функция
   chat_server_feed(). Она уже определена в chat_server.h и
  .cpp файлах. Если реализуется это, то надо определить макрос
  NEED_SERVER_FEED.

  Серверные сообщения рассылаются всем клиентам. Если сделан
  бонус с именами, то имя сервера должно быть 'server'.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 1000-1200, в среднем 1100.

- Затраченное время на все:
  * Продвинутый уровень: ~6 часов.
  * Средний уровень:    ~15 часов.
  * Мало практики:      ~20 часов и более.

- Распределение времени:
  * Активный кодинг: ~6 часов.
  * Остальное - чтение кода, понимание задачи, чтение документации
    про мультиплексирование дескрипторов через epoll/kqueue.

-------------------------- Как запусить --------------------------

Для сборки задачи используется CMake. Вот так можно им
воспользоваться:

- Идем в папку задачи, так что наш путь становится
  <...>/sysprog/5/.
- Создаем папку build и идем в нее:
    mkdir build
    cd build
- Конфигурируем:
    cmake ..
- Компилируем:
    make
- Теперь можно запустить тесты:
    ./test
- Так можно запустить клиентов и сервер:
    ./client
    ./server

В CMake можно задавать опции. Например, если есть опция
SOME_OPTION, то ее можно установить в некое значение через такую
команду:
    cmake -DSOME_OPTION=value ..

Для этой задачи доступны следующие опции:

- ENABLE_LEAK_CHECKS - собрать с утилитой heap_help, чтобы
    проверять отсутствие утечек и в целом проблем с кучей:
  - 0 = выключить
  - 1 = включить

- ENABLE_GLOB_SEARCH - собрать все C и C++ файлы в текущей папке.
    Обычно нужно, когда вы решили создать свои дополнительные
    файлы, и не хотите их все перечислять по одному.
  - 0 = выключить
  - 1 = включить

- CMAKE_BUILD_TYPE.
  - Release = включить оптимизации компилятора. Быстрее работает,
      но сложнее дебажить интерактивно.
  - Debug = выключить оптимизации компилятора. Обратный эффект от
      Release.

----------------------- Советы и подсказки -----------------------

- Лучше начать с дизайна, что собираетесь делать. Например, надо
  подумать, как писать данные в сокеты - write()/send() могут
  заслать не все сразу за раз. write(100) может запросто записать
  лишь 60 байт вместо 100. Это значит, данные для отправки должны
  быть сохранены в некий буфер, из которого они будут отсылаться
  кусками по мере возможности, когда сокет writable. Нужно
  копировать данные для отправки и следить, сколько уже
  отправлено.

- Поймите, что использовать в сервере - epoll или kqueue. Если у
  вас Linux, то это будет epoll. Если Mac, то можно взять нативно
  kqueue или использовать epoll в виртуальной машине или в Docker
  контейнере.

- Начать стоит с клиента. Он проще, чем сервер.

- Если кажется, что база легкая, то стоит сразу делать с
  поддержкой имен клиентов.

- Очень рекомендуется поисследодвать, как работае EPOLLET, если
  собираетесь взять epoll, и EV_CLEAR, если берете kqueue. Идея в
  обоих одинаковая, но проще объяснить на epoll, потому что там
  имя точнее отражает, что происходит. EPOLLET - это
  edge-triggered режим (реакция на переход состояния). По
  умолчанию epoll использует "level-triggered" (реакция на само
  состояние).

  Разница в следующем. В level-triggered режиме epoll довольно
  простой. Если юзер слушает EPOLLIN событие, и сокет читабельный,
  то epoll_wait() будет возвращать этот сокет, пока он остается
  читабельным. Тоже самое с EPOLLOUT - сокет будет возвращаться из
  epoll_wait() все время, пока он может писать.

  И это - проблема. В то время, как чтение нужно всегда, ситуация
  с записью совсем другая. Потому что приложение не всегда имеет
  данные для отправки.

  Поэтому level-triggered так называется - событие "триггерится",
  когда сокет находится в нужном состоянии ("level"), то есть
  может писать или читать. Получите вы событие из epoll_wait() или
  нет, зависит только от текущего состояния сокета.

  Edge-triggered - другой. Он реагирует (создает "событие") только
  когда сокет меняет состояние. То есть реакция не на состояние, а
  на изменение состояния.

  И вот так это проявляется - когда сокет **не мог писать** и
  вдруг **смог писать**, создается событие EPOLLOUT, и вы его
  получаете в epoll_wait(). Но если сокет уже мог писать до
  вызова epoll_wait(), то он не получит EPOLLOUT событие. То же
  самое с EPOLLIN и читабельностью сокета.

  Переход в состояние **не могу что-то делать** происходит, когда
  вы пытаетесь сделать это самое что-то (send() для записи и
  recv() для чтения) и получаете EWOULDBLOCK. В этом случае, когда
  состояние меняется и **это что-то можно сдлелать**, вы получите
  соответствующее событие.

  То есть с EPOLLET надо убедиться, что вы делаете write()/send()
  всегда до тех пор, пока не получите EWOULDBLOCK. И уже тогда
  можно перестать писать. Когда станет можно, вы получите EPOLLOUT
  из epoll_wait().

  Для EPOLLIN логика та же самая, но обычно здесь все проще,
  потому что читать вы хотите практически всегда. Очень редко,
  когда приложение не хочет читать сокет.

  С kqueue применимо все то же самое, когда используется EV_CLEAR.
