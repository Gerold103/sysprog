------------------------------------------------------------------
Игровой чат.
Язык: C.
Время: 2 недели.
------------------------------------------------------------------

Нужно реализовать чат игрового лобби. Он состоит из сервера и
клиента.

Клиент подключается к серверу, и каждое сообщение клиента
рассылается всем остальным клиентам через сервер. Получается, что
сервер - как бы игровое лобби. Каждый видит сообщения каждого и
сообщения никуда никак не сохраняются надолго.

В прикрепленных .h и .c файлах раскиданы шаблоны функций и
структур, которые надо реализовать.

Пример использования исполняемых файлов - запускается сервер и
один или несколько клиентов. Все рассылается всем:

$> ./server             $> ./client             $> ./client
I am client-1!          I am client-1!          I am client-1!
I am client-2!          I am client-2!          I am client-2!


Правила:

- Сообщение кончается `\n` (перенос строки). Заметьте, что '\n' не
  является частью сообщения. Это просто разделитель. То есть если
  вызван feed('msg\n'), то участники чата должны вернуть 'msg' из
  pop(). Также учтите, что feed() может получить несколько целых
  сообщений или даже их части:
  - feed('msg1\nmsg2\n') - pop() вернет 'msg1' и 'msg2';
  - feed('msg1\nms') - pop() вернет 'msg1'. 'ms' остается во
    внутреннем буфере пока не встретится '\n'.

- Собственные сообщения обратно клиенту с сервера не посылаются.

- Пустые сообщения (состоящие только из пробельных символов - см.
  функцию isspace()) не отправляются вообще.

- С каждого сообщения слева и справа обрезаются все пробельные
  символы. Например, если я ввожу "  m s   g   " в терминале и жму
  enter, то будет отправлено сообщение "m s   g".


Ограничения:

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.

- Нельзя использовать sleep()/usleep() или подобные функции. Все
  ожидания чего-либо должны быть сделаны на epoll или poll или
  kqueue.

- Функция select() запрещена (она устарела, сломана, и просто
  является плохой практикой - никогда ее не используйте).

- Все сокеты должны быть созданы неблокирующими (O_NONBLOCK).

- Никаких бизи-лупов (busy-loop) / активных ожиданий где-либо.

- Будьте готовы, что send/write и подобные функции отправки данных
  могут отправить часть данных, а не все целиком. Например,
  send(100) может вернуть 60.

- API в заголовках менять нельзя (кроме случаев, когда там
  ошибка - тогда надо сказать мне).

- В epoll нужно использовать epoll_event.data.ptr, а в kqueue -
  kevent.udata. Использование epoll_event.data.fd запрещено. Поля
  ptr/udata нужны для сопоставления событий к их сокетам после
  возврата событий из epoll_wait() и kevent().

- При использовании epoll нужно прочитать про EPOLLET и
  использовать его. EPOLL_CTL_MOD запрещен.

- При использовании kqueue нужно обязательно ставить EV_CLEAR.

- Прикрепленный makefile должен оставаться рабочим, компиляция
  должна иметь 0 предупреждений и ошибок. Либо можно переделать на
  cmake, но все опции компиляции нужно сохранить.


Послабления:

- Можно полагать, что очереди сообщений всегда достаточно малы,
  чтобы поместиться целиком в память.

- Можно полагать, что буферы ввода и вывода всегда помещаются в
  память.

- Можно использовать abort() для критичных ошибок. Например, если
  не получилось создать epoll-дескриптор или сокет, или malloc()
  вернул NULL.

- Буфер вывода может быть в любом формате. Например, копировать
  каждое сообщение поданное в feed() и хранить их в списке. Или
  копировать все сообщения в один большой буфер в его конец.

- Можно использовать libev, если кажется, что это будет проще, чем
  использовать напрямую epoll/kqueue (но честно говоря, вряд ли).

- Можно полагать, что клиент и сервер используют только адреса
  IPv4.


Советы:

- Лучше начать с дизайна, что собираетесь делать. Например, надо
  подумать, как писать данные в сокеты - write()/send() могут
  заслать не все сразу за раз. write(100) может запросто записать
  лишь 60 байт вместо 100. Это значит, данные для отправки должны
  быть сохранены в некий буфер, из которого они будут отсылаться
  кусками по мере возможности, когда сокет writable. Нужно
  копировать данные для отправки и следить, сколько уже
  отправлено.

- Выберите, что использовать в сервере - epoll, poll, или kqueue.
  Я рекомендую epoll/kqueue, но можно взять любое (kqueue доступен
  только на Mac/FreeBSD и epoll только на Linux).

- Начать стоит с клиента. Он проще, чем сервер.

- Если кажется, что база легкая, то стоит сразу делать с
  поддержкой имен клиентов (см. бонусы ниже).


Варианты решения:

- 15 баллов: реализовать все функции из всех .h и .c файлов, как
  описано выше и в самих файлах (кроме опциональных функций из
  бонусных решений).

- +5 баллов: поддержка имен клиентов. В chat_client_new() есть
  параметр 'name'. Его надо отправить на сервер и показывать перед
  каждым сообщением этого клиента на всех остальных клиентах. Если
  это делаете, то надо определить макрос NEED_AUTHOR.

  Для засчитывания этого бонуса клиенты должны посылать свое имя
  серверу только один раз.

- +5 баллов: реализовать серверные сообщения - функция
   chat_server_feed(). Она уже определена в chat_server.h и
  .c файлах. Если реализуется это, то надо определить макрос
  NEED_SERVER_FEED.

  Серверные сообщения рассылаются всем клиентам. Если сделан
  бонус с именами, то имя сервера должно быть 'server'.

- -5 баллов: (да, минус, не плюс) - можно использовать C++ и STL
  контейнеры.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10. Или использовать C++ и получать -5 к сумме.
