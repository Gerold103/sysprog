------------------------------------------------------------------
Файловая система.
Язык: C/C++
Время: 3 недели.
Сложность: ~7 часов в среднем, 520 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Нужно реализовать свою файловую систему в памяти. Не пугайтесь,
это не сложно. Для старта предоставляется шаблон интерфейса с
некоторыми уже реализованными структурами, в файлах userfs.h и
userfs.cpp.

Файловая система называется UserFS, и очень примитивна. В ней нет
папок - все файлы лежат в "руте". Файлы можно создавать, удалять,
открывать на них дескрипторы и закрывать их. Каждый файл похож по
структуре на файловую систему FAT: это список блоков. В userfs.cpp
можно посмотреть структуры, которые описывают блок и файл, где
лежит их список.

На диске не хранится ничего - все в оперативной памяти, на куче.
Файлы можно читать/писать по дескриптору. API очень похоже на
реальное из libc. Полное описание доступно в userfs.h.

Задача - реализовать это API так, как описано в комментариях в
userfs.h.

---------------------------- Правила -----------------------------

- Нужно строго следовать поведению всех функций как оно описано в
  комментариях в userfs.h.

-------------------------- Ограничения ---------------------------

- userfs.h нельзя менять кроме как для включения бонусов. Они
  описаны ниже.

- Нельзя копировать буферы в ufs_read/write() по одному байту.
  Нужно использовать memcpy() для чтения и записи блоков, много
  байтов за раз.

- Тесты менять нельзя.

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  опцию cmake - `ENABLE_LEAK_CHECKS`. Показать репорты с нулем
  утечек от Valgrind или ASAN не достаточно - они часто пропускают
  утечки.

-------------------------- Послабления ---------------------------

- Можно считать, что функции работы с памятью типа new/delete/
  malloc()/realloc()/calloc() никогда не ошибаются.

------------------------ Варианты решения ------------------------

- 15 баллов: реализовать все функции из userfs.h.

- +5 баллов: добавить поддержку режима открытия файла: для чтения,
  записи, и обоих операций вместе. См. NEED_OPEN_FLAGS в userfs.h
  и в тестах. Файловый дескриптор, открытый на чтение, не может
  быть использован для записи, и тоже самое обратно. По умолчанию
  файл должен открываться в режиме чтения-записи вместе.

- +5 баллов: добавить поддержку изменения размера файла. См.
  NEED_RESIZE в userfs.h.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 330-640, в среднем 520.

- Затраченное время на все:
  * Продвинутый уровень: ~4 часов.
  * Средний уровень:     ~7 часов.
  * Мало практики:       ~10 часов и более.

- Распределение времени: написание кода и отладка в целом
  равномерно распределены. Про эту задачу говорят, что ее легко
  понять и не сложно закодить и отладить.

-------------------------- Как запусить --------------------------

Для сборки задачи используется CMake. Вот так можно им
воспользоваться:

- Идем в папку задачи, так что наш путь становится
  <...>/sysprog/3/.
- Создаем папку build и идем в нее:
    mkdir build
    cd build
- Конфигурируем:
    cmake ..
- Компилируем:
    make
- Теперь можно запустить тесты:
    ./test

В CMake можно задавать опции. Например, если есть опция
SOME_OPTION, то ее можно установить в некое значение через такую
команду:
    cmake -DSOME_OPTION=value ..

Для этой задачи доступны следующие опции:

- ENABLE_LEAK_CHECKS - собрать с утилитой heap_help, чтобы
    проверять отсутствие утечек и в целом проблем с кучей:
  - 0 = выключить
  - 1 = включить

- ENABLE_GLOB_SEARCH - собрать все C и C++ файлы в текущей папке.
    Обычно нужно, когда вы решили создать свои дополнительные
    файлы, и не хотите их все перечислять по одному.
  - 0 = выключить
  - 1 = включить

- CMAKE_BUILD_TYPE.
  - Release = включить оптимизации компилятора. Быстрее работает,
      но сложнее дебажить интерактивно.
  - Debug = выключить оптимизации компилятора. Обратный эффект от
      Release.

----------------------- Советы и подсказки -----------------------

- Тесты собранные с heap_help будут очень долго проходить. Чтобы
  это обойти, рекомендуется временно увеличить BLOCK_SIZE у себя в
  коде до, например, 4096. Это значительно ускорит тесты, при этом
  сохранив проверку утечек.

  Дефолтный размер блока должен работать быстро без heap_help.

- Далее следует несколько примеров и предложений по возможному
  подходу к решению.

Ваша основная задача - реализовать увеличение файла по мере записи
в него, и реализовать файловый дескриптор. Рассмотрим пару
примеров.

Есть код:

        int fd = ufs_open("any_file_name", UFS_CREATE);

После этой строки внутри userfs.cpp создается struct file с именем
"any_file_name", если его еще нет. Затем создается файловый
дескриптор struct filedesc.

        const char *data = "bla bla bla";
        ufs_write(fd, data, strlen(data));

Файл пустой, в нем нет блоков, поэтому вам нужно аллоцировать
нужное число блоков struct block. В данном случае это 1. В него
копируем данные. Ваш файл начинает выглядеть так:

        file:
        +---------------------+
        | bla bla bla|        | -> NULL.
        +---------------------+
                     ^
                  filedesc - дескриптор указывает сюда. Например,
                             в дескрипторе вы можете хранить
                             номер блока и смещение в нем.

Затем я продолжаю писать, но уже больше данных:

        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ufs_write(fd, buf, sizeof(buf));

Вот что получится:

        file:
        +---------------------+    +---------------------+
        | bla bla bla 0 0 0 0 | -> | 0 0 0 0 0 0 0 0 0 0 | ->
        +---------------------+    +---------------------+

        +---------------------+
     -> | 0 0 0 0 0 0|        | -> NULL.
        +---------------------+
                     ^
                  filedesc

То есть понадобилось дозаполнить уже имеющийся блок, и создать еще
два блока. Они просто добавились в конец списка.

Тоже самое с чтениями - дескриптор читает последовательно
перепрыгивая на следующий блок, когда дочитал предыдущий.
