------------------------------------------------------------------
Файловая система.
Язык: С.
Время: 3 недели.
Сложность: ~7 часов в среднем, 520 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Нужно реализовать свою файловую систему в памяти. Не пугайтесь,
это не сложно. Для старта предоставляется шаблон интерфейса с
некоторыми уже реализованными структурами, в файлах userfs.h и
userfs.c.

Файловая система называется UserFS, и очень примитивна. В ней нет
папок - все файлы лежат в "руте". Файлы можно создавать, удалять,
открывать на них дескрипторы и закрывать их. Каждый файл похож по
структуре на файловую систему FAT: это список блоков. В userfs.c
можно посмотреть структуры, которые описывают блок и файл, где
лежит их список.

На диске не хранится ничего - все в оперативной памяти, на куче.
Файлы можно читать/писать по дескриптору. API очень похоже на
реальное из libc. Полное описание доступно в userfs.h.

Задача - реализовать это API так, как описано в комментариях в
userfs.h.

---------------------------- Правила -----------------------------

- Нужно строго следовать поведению всех функций как оно описано в
  комментариях в userfs.h.

-------------------------- Ограничения ---------------------------

- userfs.h нельзя менять кроме как для включения бонусов. Они
  описаны ниже.

- Нельзя копировать буферы в ufs_read/write() по одному байту.
  Нужно использовать memcpy() для чтения и записи блоков, много
  байтов за раз.

- Тесты менять нельзя.

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.

-------------------------- Послабления ---------------------------

- Можно полагать, что все данные помещаются в оперативную память,
  и функции ее выделения (такие как malloc()) всегда успешны.

------------------------ Варианты решения ------------------------

- 15 баллов: реализовать все функции из userfs.h.

- +5 баллов: добавить поддержку режима открытия файла: для чтения,
  записи, и обоих операций вместе. См. NEED_OPEN_FLAGS в userfs.h
  и в тестах. Файловый дескриптор, открытый на чтение, не может
  быть использован для записи, и тоже самое обратно. По умолчанию
  файл должен открываться в режиме чтения-записи вместе.

- +5 баллов: добавить поддержку изменения размера файла. См.
  NEED_RESIZE в userfs.h.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 330-640, в среднем 520.

- Затраченное время на все:
  * Продвинутый уровень: ~4 часов.
  * Средний уровень:     ~7 часов.
  * Мало практики:       ~10 часов и более.

- Распределение времени: написание кода и отладка в целом
  равномерно распределены. Про эту задачу говорят, что ее легко
  понять и не сложно закодить и отладить.

----------------------- Советы и подсказки -----------------------

- Тесты собранные с heap_help будут очень долго проходить. Чтобы
  это обойти, рекомендуется временно увеличить BLOCK_SIZE у себя в
  коде до, например, 4096. Это значительно ускорит тесты, при этом
  сохранив проверку утечек.

  Дефолтный размер блока должен работать быстро без heap_help.

- Далее следует несколько примеров и предложений по возможному
  подходу к решению.

Ваша основная задача - реализовать увеличение файла по мере записи
в него, и реализовать файловый дескриптор. Рассмотрим пару
примеров.

Есть код:

        int fd = ufs_open("any_file_name", UFS_CREATE);

После этой строки внутри userfs.c создается struct file с именем
"any_file_name", если его еще нет. Затем создается файловый
дескриптор struct filedesc.

        const char *data = "bla bla bla";
        ufs_write(fd, data, strlen(data));

Файл пустой, в нем нет блоков, поэтому вам нужно аллоцировать
нужное число блоков struct block. В данном случае это 1. В него
копируем данные. Ваш файл начинает выглядеть так:

        file:
        +---------------------+
        | bla bla bla|        | -> NULL.
        +---------------------+
                     ^
                  filedesc - дескриптор указывает сюда. Например,
                             в дескрипторе вы можете хранить
                             номер блока и смещение в нем.

Затем я продолжаю писать, но уже больше данных:

        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ufs_write(fd, buf, sizeof(buf));

Вот что получится:

        file:
        +---------------------+    +---------------------+
        | bla bla bla 0 0 0 0 | -> | 0 0 0 0 0 0 0 0 0 0 | ->
        +---------------------+    +---------------------+

        +---------------------+
     -> | 0 0 0 0 0 0|        | -> NULL.
        +---------------------+
                     ^
                  filedesc

То есть понадобилось дозаполнить уже имеющийся блок, и создать еще
два блока. Они просто добавились в конец списка.

Тоже самое с чтениями - дескриптор читает последовательно
перепрыгивая на следующий блок, когда дочитал предыдущий.
