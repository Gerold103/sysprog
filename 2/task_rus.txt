------------------------------------------------------------------
Shell.
Язык: C/C++
Время: 3 недели.
Сложность: ~15 часов в среднем, 350 строк кода.
------------------------------------------------------------------

Прочтите описание целиком. Оно содержит не только условие задачи,
но и подсказки, учебные материалы, оценки сложности, правила,
указания на частые ошибки, и предлагает бонусные задачи.

---------------------------- Условие -----------------------------

Нужно написать упрощенную версию командной строки. Она должна
принимать на вход строки вида:

    > command_name param1 param2 ...

и выполнять их при помощи вызова команды command_name с
параметрами. То есть работать как терминал.

Файлы parser.h и parser.cpp уже реализуют парсер. Вы свобдны взять
его, или реализовать свой, или взять какой-нибудь еще.

Файл parser_test.cpp можно игнорировать. Он используется для
тестирования готового парсера. Этот тест не нужно никуда
присылать или даже открывать (кроме как если хотите посмотреть
примеры использования парсера).

Единственный файл, который требует вашего внимания - solution.cpp.
Он содержит шаблон решения. Но вы можете создать сколько угодно
своих файлов дополнительно, если нужно.

Поведение вашего терминала должно повторять Bash в точности. Как
минимум в тех аспектах, которые требуются в задаче и тестах.

---------------------------- Правила -----------------------------

- Нужно, чтобы программа правильно обрабатывала строки,
  заключенные в кавычки, как одну большую строку, даже если там
  есть пробелы.

- Комментарии тоже должны обрабатываться верно, то есть
  обрезаться.

- Кроме того, должен поддерживаться конвейер, или иначе говоря
  pipe, который делается символом |, а так же перенаправление
  вывода в файл (>, >>).

- На выход программа должна печатать все то же, что и обычный
  терминал. Как /bin/bash.

- Необходимо использовать функции pipe(), dup/dup2(), fork(),
  wait(), open(), close(), как минимум одну из функций семейства exec:
  execl, execle, execlp, execv, execvp, execvP().

- Команду 'cd' нужно реализовать самому, а не просто вызвать ее
  через exec. Потому что она меняет текущую директорию самого
  терминала. К счастью, это легко делается C функцией chdir().

- Команда 'exit' тоже специальная как 'cd'. Потому что влияет на
  сам терминал. Ее нужно реализовать вручную. Но учтите, что она
  затрагивает терминал только в одном случае: вывод exit должен
  быть в shell. Если вывод перенаправлен, то shell не завершается.
  Например, 'exit', 'exit 123 && echo test',
  'exit 456 || echo test' - все завершают терминал. Но
  'exit | echo 100' - нет. Если есть сомнения, нужно проверить,
  как себя ведет /bin/bash, и делать также.

- Терминал должен поддерживать токены написаные без пробелов
  (если /bin/bash тоже может). Например:
  'echo "4">file' (работает как 'echo "4" > file'), или
  'echo 100|grep 100' (работает как 'echo 100 | grep 100').

- Когда неясно, как что-то должно работать, стоит проверить это в
  настоящем терминале типа /bin/bash. И затем повторить это
  поведение.

- Код должен собираться успешно с данными флагами компилятора:
  `-Wextra -Werror -Wall -Wno-gnu-folding-constant`.

-------------------------- Ограничения ---------------------------

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  опцию cmake - `ENABLE_LEAK_CHECKS`. Показать репорты с нулем
  утечек от Valgrind или ASAN не достаточно - они часто пропускают
  утечки.

- Нельзя использовать malloc(), realloc(), calloc(), и подобные
  функции. Можно использовать только new и delete из C++.

- Длина входной строки не ограничена, сохранять ее в буфер заранее
  предаллоцированного размера нельзя. Но в оперативную память
  каждая строка очевидно помещается.

- Запрещается использовать функции вроде system(), popen(), или
  еще каким-то образом пытаться обращаться к терминалу или
  автоматическому созданию конвейеров.

-------------------------- Послабления ---------------------------

- Не нужно поддерживать перенаправление потоков по номерам/именам,
  типа stderr. Эти команды - 1>, 2>, $>, 1>> - и подобные
  поддерживать не обязательно. (Обычные > и >> все еще надо.)

- Не нужна поддержка множественного перенаправление типа
  'cmd > file1 > file2' или 'cmd > file1 file2'.

- Не нужно поддерживать '~' и '-' в реализации команды 'cd'.

- Можно использовать уже написанный парсер из parser.h и .cpp, с
  примером использования в solution.cpp.

- Можно считать, что функции работы с памятью new и delete никогда
  не ошибаются.

------------------------ Варианты решения ------------------------

- 15 баллов: все описанное выше.

- +5 баллов: поддержка &.

- +5 баллов: поддержка операторов && и ||. Учтите, что этот бонус
  весьма нетривиален.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.

Вход: команды и их аргументы, операторы перенаправления
выводов/вводов.

Выход: то же, что выводит Bash.

--------------------------- Сложность ----------------------------

Сколько времени и сил займет сделать эту задачу. Числа могут
помочь вам с планированием. Они собраны на студентах, кто сделал
задачу до конца хотя бы на минимальные баллы.

- Строк кода: 200-450, в среднем 350.

- Затраченное время на все:
  * Продвинутый уровень: ~10 часов.
  * Средний уровень:     ~15 часов.
  * Мало практики:       ~20 часов и более.

- Распределение времени: написание кода и отладка в целом
  равномерно распределены. На самом деле, кода не так уж и много
  писать, но отладка вероятно займет прилично времени.

-------------------------- Как запусить --------------------------

Для сборки задачи используется CMake. Вот так можно им
воспользоваться:

- Идем в папку задачи, так что наш путь становится
  <...>/sysprog/2/.
- Создаем папку build и идем в нее:
    mkdir build
    cd build
- Конфигурируем:
    cmake ..
- Компилируем:
    make
- Теперь можно запустить свой терминал:
    ./mybash

В CMake можно задавать опции. Например, если есть опция
SOME_OPTION, то ее можно установить в некое значение через такую
команду:
    cmake -DSOME_OPTION=value ..

Для этой задачи доступны следующие опции:

- ENABLE_LEAK_CHECKS - собрать с утилитой heap_help, чтобы
    проверять отсутствие утечек и в целом проблем с кучей:
  - 0 = выключить
  - 1 = включить

- ENABLE_GLOB_SEARCH - собрать все C и C++ файлы в текущей папке.
    Обычно нужно, когда вы решили создать свои дополнительные
    файлы, и не хотите их все перечислять по одному.
  - 0 = выключить
  - 1 = включить

- CMAKE_BUILD_TYPE.
  - Release = включить оптимизации компилятора. Быстрее работает,
      но сложнее дебажить интерактивно.
  - Debug = выключить оптимизации компилятора. Обратный эффект от
      Release.

------------------------- Примеры ввода --------------------------

* Распечатать список процессов и найти среди них строку init.

    > ps aux | grep init

* Выполнить код в python и выполнить поиск по его результату:

    > echo "print('result is ', 123 + 456)" | python -i | grep result

* Печать экранированной кавычки в файл и его вывод:

    > echo "some text\" with quote" > test.txt
    > cat test.txt

* Дописывание в файл:

    > echo "first data" > test.txt
    > echo "second" >> test.txt
    > cat test.txt

* Запустить интерактивную консоль python и что-то в ней сделать:

    > python
    >>> print(1 + 2)
    >>> 3

----------------------- Советы и подсказки -----------------------

- Попробуйте реализовать простой main.cpp пример с одной
  захардкоженной командой, которая вы выполняете через fork() +
  exec...().

  Затем усложняйте. Например, соедините две захардкоженные команды
  через один pipe(). Допустим, `echo abc | grep a`. Используйте
  fork() + exec...() + pipe() + dup2(), чтобы вывод первой команды
  пошел на вход второй.

  Когда это заработало, добавьте третью команду:
  `echo abc | grep a | cat`, например. Вам понадобится 3 fork()-а,
  два pipe()-а, и несколько dup2(). Когда такой конвейер работает,
  вы увидите паттерн, как сделать 4 команды, 5, и тд.

- Перед началом работы ознакомьтесь с парсером и его API.

- В начале реализуйте выполнение команд без |, >, >>. Просто чтобы
  выполнялась одна команда.

- Тесты в tests.txt вы можете редактировать для отладки. Или
  копипастить их в свой терминал вручную для ручной отладки.
  Например, попробуйте прогнать только первые тесты из tests.txt
  через checker.py, удалив все остальные тесты.

- Добавьте поддержку |, >, >>. Одну за одной. Лучше всего делать
  работу итеративно. Не пытайтесь реализовать все и сразу. Все
  равно в реальной разработке так никто не делает. Код всегда
  расширяется постепенно. Новая функциональность добавляется
  по очереди.

- Попробуйте спросить ChatGPT или любой другой ИИ вопросы про
  Bash, pipe-ы, fork-и, и exec-и. Обычно чат-боты довольно хорошо
  отвечают.

- Используйте настоящий /bin/bash для тестирования, как некоторые
  команды должны себя вести. Внимание - ваш терминал по-умолчанию
  может быть не Bash, а например zsh, особенно если у вас MacOS.
  Лучше явно запускать бинарь /bin/bash. В нем можно делать свои
  тесты, которые хочется проверить, как должны работать.

- Если возникают сложности с поддержкой команды `exit` и ее
  exit-кодами, то можно проверять эти команды в Bash и
  использовать команду `echo $?`, чтобы узнать код выхода
  предыдущей команды. И дальше просто повторяете это поведение в
  своей реализации.

- Когда пытаетесь пройти тесты, не забудьте удалить или
  закомментировать свои отладочные сообщения. Иначе они будут
  попадать в вывод и ломать тесты.

- Возможно, отладка через gdb или lldb окажется для вас довольно
  сложной, так как отладчики в целом не очень хорошо дружат с
  многопроцессными приложениями. Вам придется использовать
  printf()-ы. Для упрощения вам может помочь завернуть функцию
  логов в макрос, например `#define mylog printf`, чтобы легко
  выключить все логи перед тестами checker.py через
  `#define mylog(...)` (то есть макрос определяется в пустоту).

  Кроме того, некоторые логи в дочерних процессах вы возможно не
  увидите, если пишете их в STDOUT через printf(), потому что
  очевидно в дочерних процессах STDOUT может быть перенаправлен в
  файл или в другой процесс. Будет удобнее писать логи в некий
  файл, пусть даже по захардкоженному пути где-то в вашей папке с
  решением. Так все процессы будут писать логи в место, которое не
  влияет на тесты и не мусорит в STDOUT.

- Будте очень осторожны с закрытием pipe-ов корректно. Помните,
  что если вы забудете закрыть читающий конец пайпа, то писатель
  может зависнуть. И наоборот. Также помните, что если вы создаете
  pipe(int[2]) и зовете fork(), то теперь у вас и родитель, и
  потомок имеют два дескриптора на один и тот же pipe, 4 в сумме.
  Лучше всего после открытия pipe-а и fork() сразу же в родителе и
  в потомке закрывать ненужные концы pipe-а.

- Попробуйте увеличить лимит на файловые дескрипторы в своем
  терминале, где вы запускаете тесты (смотрите команду
  `ulimit -n`), если у вас появляются странные ошибки при октрытии
  большого кол-ва пайпов (но возможно вы просто не закрываете
  лишние концы).

Архитектура решения может быть такой: есть процесс-терминал,
который читает команды. На каждую команду он делает fork(). Новый
потомок выполяет команду через exec*() функции. Родительский
процесс ждет завершения потомка.

На каждый | терминал должен открыть pipe(), который свяжет
вывод предыдущей команды и ввод следующей команды.

Для > и >> терминал открывает файл и, используя dup/dup2(), в
процессе-потомке меняет стандартный вывод, чтобы он писался в
файл.
